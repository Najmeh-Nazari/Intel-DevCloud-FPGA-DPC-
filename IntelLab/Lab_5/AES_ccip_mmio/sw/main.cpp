
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.


// This example demonstrates an AFU wrapper class built around the OPAE API 
// to do the following:
// 1) request an FPGA with a specific AFU
// 2) read and write from a memory-mapped register in the FPGA 

#include <cstdlib>
#include <iostream>

#include <opae/utils.h>

#include "AFU.h"

using namespace std;

// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"

//=========================================================
// Define the address of the memory-mapped register according the address
// that was used in the RTL code.
//
// NOTE: Ideally this could be generated with a .json file just like the
// AFU_ACCEL_UUID. Without auto-generation, you must manually ensure that
// the addresses match between the RTL code and software code.
//=========================================================
#define DIN_REG_L_ADDR 0x0020
#define DIN_REG_H_ADDR 0x0022
#define KEY_REG_L_ADDR 0x0024
#define KEY_REG_H_ADDR 0x0026
#define DOUT_REG_L_ADDR 0x0028
#define DOUT_REG_H_ADDR 0x002A
#define INIT_REG_ADDR 0x002C
#define START_REG_ADDR 0x002E
#define READY_REG_ADDR 0x0030
#define DONE_REG_ADDR 0x0032
#define DONE_INIT_REG_ADDR 0x0034



int main(int argc, char *argv[]) {

  try {
    // Create an AFU object to provide basic services for the FPGA. The 
    // constructor searchers available FPGAs for one with an AFU with the
    // the specified ID
    AFU afu(AFU_ACCEL_UUID);
    
    // Test 100 different writes and reads to the user MMIO register.
    unsigned errors = 0;
	
	uint64_t ready = 0; 
	uint64_t done_init = 0; 
	uint64_t done = 0;
	uint64_t dout_l = 0;
	uint64_t dout_h = 0;
	
	
	afu.write(INIT_REG_ADDR, 0);
	afu.write(START_REG_ADDR, 0);
	
	afu.write(KEY_REG_L_ADDR, 0x08090A0B0C0D0E0F);
	afu.write(KEY_REG_H_ADDR, 0x0001020304050607);
	
	afu.write(DIN_REG_L_ADDR, 0x8899AABBCCDDEEFF);
	afu.write(DIN_REG_H_ADDR, 0x0011223344556677);
	
	

	ready = afu.read(READY_REG_ADDR);
	cout << "READY signal is: " << ready << endl; 
	
	afu.write(INIT_REG_ADDR, 1);
	//afu.write(INIT_REG_ADDR, 0);
	
	while(done_init != 1)
	{
		
		done_init = afu.read(DONE_INIT_REG_ADDR);
		//cout << "done_init signal is: " << done_init << endl;
	}
	afu.write(INIT_REG_ADDR, 0);
	cout << "DONE_INIT signal is: " << done_init << endl;
	
	afu.write(START_REG_ADDR, 1);
	
	
	while(done != 1)
	{
		
		done = afu.read(DONE_REG_ADDR);
		
	}
	
	afu.write(START_REG_ADDR, 0);
	cout << "DONE signal is: " << done << endl;
	
	dout_l = afu.read(DOUT_REG_L_ADDR);
	dout_h = afu.read(DOUT_REG_H_ADDR);
	
	cout << "Encrypted MSG is: 0x" << std::hex << dout_h << std::hex << dout_l << endl;
	
	if(dout_l != 0xD8CDB78070B4C55A && dout_h != 0x69C4E0D86A7B0430)
	{
		cerr << "ERROR: Read from DOUT register has incorrect value!"<< endl;
		errors ++;
	}
	
	
    if (errors == 0) {
      cout << "AES tests succeeded." << endl;
      return EXIT_SUCCESS;
    }
    else {
      cout << "AES tests failed." << endl;
      return EXIT_FAILURE;
    }
  }
  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}